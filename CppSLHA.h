// Ben O'Leary, 8th July 2010.  NOT FOR PUBLIC DISTRIBUTION.  If this code has been included in a public release, covered by the GNU license agreement or similar, then this warning is obviously a holdover from pre-release, & should be disregarded in favor of the release agreement.  This code is based in part on what I learned from reading some private code by Martin Wiebusch (mwiebusch@physik.rwth-aachen.de), along with examples from the cplusplus.com website.
// this is the .hpp file for a C++ class that reads a supplied SLHA file & stores the masses & decays of the sparticles in a BOL_EW_scale_MSSM_spectrum instance & the rest in arrays of doubles.



/*********************************************************************
 *                                                                   *
 * IMPORTANT!                                                        *
 *                                                                   *
 * welcome, person who has decided to read this file.                *
 *                                                                   *
 * i hope that you will find these classes easy to use.  i have      *
 * tried to make the variable names self-explanatory, & hope that    *
 * the comments are adequate to explain the logic of the code.       *
 *                                                                   *
 * all dimensionful quantities in the code are assumed to be in GeV. *
 *                                                                   *
 * the logic of this class is that it reads in an SLHA-format file   *
 * generated by SPheno or SUSY-HIT (SDECAY+SUSPECT) or SOFTSUSY or   *
 * whatever, stores the data internally & gives out data roughly as  *
 * someone would ask someone else to read out an entry from the file *
 * (e.g. "please find the SMINPUTS BLOCK then tell me the value at   *
 * entry 3").  it makes no attempt to make it any more intuitive     *
 * than that, it just adheres to the SLHA standard.                  *
 *                                                                   *
 *                                                                   *
 * usage instructions:                                               *
 *                                                                   *
 * vanilla MSSM with R-parity:                                       *
 * just create a CppSLHA instance with the name of the SLHA file to  *
 * be read, then access the data with the methods "get_BLOCK"        *
 * with arguments that are                                           *
 * 1st - the block name (whether the characters are uppercase or     *
 * lowercase doesn't matter) as a std::string                        *
 * 2nd - the integer or integers that specify which value within the *
 * BLOCK is being sought.                                            *
 * e.g.                                                              *
 * CppSLHA SLHAdata( "/path/SPheno.spc" );                           *
 * double x = SLHAdata.get_BLOCK( "SMINPUTS", 4 );                   *
 * x will now be the read-in value for the pole mass of the Z boson  *
 * used by SPheno.                                                   *
 *                                                                   *
 * NMSSM or other non-standard SUSY model:                           *
 * 1st extend the BOL_EW_scale_spectrum class as necessary (see the  *
 * class definition of BOL_EW_scale_NMSSM_spectrum in                *
 * BOL_EW_scale_spectrum.hpp for an example of how to do this for    *
 * the NMSSM).  then, in the code, create an instance of this class, *
 * then pass a pointer to this spectrum as the 2nd argument of the   *
 * CppSLHA constructor.                                              *
 * e.g.                                                              *
 * BOL_EW_scale_spectrum* extended_spectrum =                        *
 *                        new example_new_extended_SSM_spectrum();   *
 * CppSLHA SLHAdata( "/path/SPheno.spc", extended-spectrum );        *
 * double x = SLHAdata.get_BLOCK( "MASS", 123456789 );               *
 * x will now be the mass of the new particle in the                 *
 * example_new_extended_SSM_spectrum which has been given the number *
 * 123456789 as its PDG MC code.                                     *
 *                                                                   *
 * if the data need to be updated, just run SLHAdata.read_file()     *
 * or, if a different file needs to be read (overwriting the         *
 * originally-read-in data), run SLHAdata.read_file with the file's  *
 * name as a std::string argument.                                   *
 *                                                                   *
 * alternatively, one can access the values more directly with       *
 * methods "get_" then the BLOCK name, e.g. "get_NMIX( 1, 2 )" is a  *
 * more direct way of accessing the { 1, 2 } element of the NMIX     *
 * BLOCK than "get_BLOCK( "NMIX", 1, 2 )" (since all "get_BLOCK"     *
 * does is compare strings then call the relevant "get_WHATEVER").   *
 *                                                                   *
 * decays are also implemented, idiosyncratically.  following the    *
 * precedent of "get_BLOCK", one can also call                       *
 * "get_branching_ratio" with 3 or 4 int arguments, which are:       *
 * 1st: the PDG MC code of the decaying particle, then               *
 * 2nd, 3rd & maybe 4th: the PDC MC codes of the decay products.     *
 * it returns the branching ratio for the specified decay.           *
 * more flexibility is available with "get_DECAY" which takes the    *
 * PDG MC code (int) of the decaying particle & returns a pointer to *
 * an instance of a BOL_particle_decay_set_handler for the decaying  *
 * particle, which contains a list of lists of ints of PDG MC codes  *
 * with associated doubles for branching ratios, & has various       *
 * methods which i hope are helpful.  see BOL_particle_data.hpp for  *
 * this class.                                                       *
 *                                                                   *
 * writing output:                                                   *
 *                                                                   *
 *                                                                   *
 *                                                                   *
 * FURTHER NOTES:                                                    *
 * all the values are set to -10^10 on initialization before the     *
 * file is read in, which should be a really obvious "error flag",   *
 * EXCEPT the elements of YU, YD, YE, AU, AD & AE, since SPheno &    *
 * SUSY-HIT at least don't bother to print them to their SLHA output *
 * files.  because of this, these elements GET INITIALIZED TO ZERO,  *
 * & i cannot think of a good way to flag if they have been set to   *
 * zero by reading in the file.                                      *
 *                                                                   *
 * NOT IMPLEMENTED:                                                  *
 * currently, this code cannot cope with multiple versions of the    *
 * same BLOCK at different scales.  some day i might re-write this   *
 * class to accommodate that (probably with a std::list of           *
 * polymorphic BLOCK objects).  until then, please stick to simple   *
 * SLHA files.                                                       *
 *                                                                   *
 *********************************************************************/



// this should prevent this class being included multiple times.

#ifndef CPPSLHA_HPP
#define CPPSLHA_HPP


// other defines:
// none

// includes:

#include <stdlib.h>
#include <math.h>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include "BOL_EW_scale_NMSSM_spectrum.h"

// namespace:
// none


class CppSLHA // this class reads in a SLHA format file & stores the data internally,
              // to be accessed in the format "get_BLOCK( BLOCKNAME, element, element ) (or with less elements, depending on the BLOCK).
{

private:

  // internal properties:

  enum BLOCK_enum  // this is an enum to cover all the BLOCKs stored.
  {

    MODSEL,
    MINPAR,
    EXTPAR,
    SMINPUTS,
    GAUGE,
    YU,
    YD,
    YE,
    AU,
    AD,
    AE,
    MSOFT,
    MASS,
    ALPHA,
    HMIX,
    STOPMIX,
    SBOTMIX,
    STAUMIX,
    NMIX,
    UMIX,
    VMIX,
    DECAY,  // there is no DECAY BLOCK, but it is a handy way of thinking about the way decays are stored.
    SPHENOLOWENERGY,  // this is SPheno-specific.  maybe someday i may get around to putting in other spectrum-generator-specific BLOCKs.
    UNKNOWN

  };

 BOL_EW_scale_spectrum* particle_spectrum;
  // see BOL_LHC_spectrum.hpp for details, but this class should take care of any normal usage without worrying about the details of
  // how that class stores the particle masses.  actually, normal use that requires decays probably does need to know the details of
  // how the decays are stored.  this class does provide basic access to the decays, in the sense that it can return the branching ratio
  // for a specified decay (so 0.0 is returned for decays that do not happen), but it's relatively restrictive, whereas the
  // BOL_particle_decay_set_handler class & the classes it relies on allow for much more flexibility.

  int model_selection;
  double SUSY_scale;
  double minimal_parameters[ 6 ];
  double extra_parameters[ 21 ];
  double Standard_Model_inputs[ 7 ];
  double gauge_couplings[ 3 ];
  double up_type_Yukawa_matrix[ 3 ][ 3 ];
  double down_type_Yukawa_matrix[ 3 ][ 3 ];
  double charged_lepton_Yukawa_matrix[ 3 ][ 3 ];
  double up_type_soft_trilinear_term_matrix[ 3 ][ 3 ];
  double down_type_soft_trilinear_term_matrix[ 3 ][ 3 ];
  double charged_lepton_soft_trilinear_term_matrix[ 3 ][ 3 ];
  double soft_mass_terms[ 20 ];
  // masses: contained in particle_spectrum.
  double EWSB_scalar_mixing_angle;
  double EWSB_scalar_mixing_parameters[ 4 ];
  double stop_mixing_matrix[ 2 ][ 2 ];
  double sbottom_mixing_matrix[ 2 ][ 2 ];
  double stau_mixing_matrix[ 2 ][ 2 ];
  double neutralino_mixing_matrix[ 4 ][ 4 ];
  double chargino_U_mixing_matrix[ 2 ][ 2 ];
  double chargino_V_mixing_matrix[ 2 ][ 2 ];
  // decays: contained in particle_spectrum.
  double SPheno_low_energy_observables[ 23 ];

  std::string SLHA_file_name;

  bool allocated_spectrum_memory;  // this is to keep track of whether the destructor needs to deallocate memory or not.


public:

  // 1st, a workaround for the iostream std::toupper "conflict":
  template <int (*F) (int)> static int safeToUpperThing (unsigned char c) { return F(c); }


  // statics:
  static std::string SLHA_double( double given_double )
  // this prepares a string that is the ASCII version of a double, in the form necessary for an SLHA file (Fortran E16.8).
  // 1st character: either - for negative numbers, of a blank space for positive numbers,
  // 2nd character: the 1st digit,
  // 3rd character: the decimal point,
  // 4th-11th characters: the 1st 8 digits following the decimal point,
  // 12th character: E
  // 13th character: + or -, depending on the sign of the exponent,
  // 14th, 15th & 16th characters: the absolute value of the exponent, with a preceding 0s to fill to 3 characters.
  // SPheno almost uses this format, but only prints 2 digits of the exponent.
  ;

  static std::string SLHA_int( int given_int, int given_size )
  // this prepares a string that is the ASCII version of an int, in the form necessary for an SLHA file
  // (Fortran Iw, where w is an integer, which is given as given_size).  the string is given_size characters long.
  ;


  // constructors:

  CppSLHA( std::string given_SLHA_file_name )  // the constructor requires a file to open.
  ;

  CppSLHA( std::string given_SLHA_file_name, BOL_EW_scale_spectrum* given_spectrum )
  // this constructor requires a file to open, & this one takes a pre-existing BOL_EW_scale_spectrum,
  // which is how one can implement the NMSSM or similar.
  ;

  CppSLHA( CppSLHA* copy_source )
  // this constructor copies another instance.
  ;


  // getters, setters and other inline functions:

  inline int get_MODSEL()
  {

	return this->model_selection;

  };


  inline double get_ALPHA()
  {

    return this->EWSB_scalar_mixing_angle;

  };


  inline double get_Q()
  {

	return this->SUSY_scale;

  };


  inline void set_MODSEL( int set_value )
  {

	this->model_selection = set_value;

  };


  inline void set_ALPHA( double set_value )
  {

	this->EWSB_scalar_mixing_angle = set_value;

  };


  inline void set_Q( double set_value )
  {

	this->SUSY_scale = set_value;

  };


  inline void set_MASS( int requested_element, double set_value )
  {

    this->particle_spectrum->record_PDG_coded_mass( requested_element, set_value );

  };


  inline BOL_particle_decay_set_handler* get_DECAY( int decayer_code )
  // this returns a pointer to an instance of the BOL_particle_data::BOL_particle_decay_set_handler class, see BOL_particle_data.hpp.
  {

    return this->particle_spectrum->get_particle_property_set( decayer_code )->get_direct_decay_handler();

  };

  inline double get_branching_ratio( int decayer_code, int product_one_code, int product_two_code )
  // this returns the branching ratio for a specified 2-body decay of a particle with PDG MC code decayer_code into
  // decay products with PDG MC codes product_one_code & product_two_code.
  {

    return this->particle_spectrum->get_particle_property_set(
			           decayer_code )->get_direct_decay_handler()->get_branching_ratio_for_exact_match( product_one_code,
														    product_two_code );

  };


  inline double get_branching_ratio( int decayer_code, int product_one_code, int product_two_code, int product_three_code )
  // this returns the branching ratio for a specified 3-body decay of a particle with PDG MC code decayer_code into
  // decay products with PDG MC codes product_one_code, product_two_code & product_three_code.
  {

    return this->particle_spectrum->get_particle_property_set(
			           decayer_code )->get_direct_decay_handler()->get_branching_ratio_for_exact_match( product_one_code,
												                    product_two_code,
														    product_three_code );

  };


  inline BOL_EW_scale_spectrum* get_particle_spectrum()
  // this returns the particle spectrum as a pointer to an instance of the BOL_EW_scale_spectrum::BOL_EW_scale_spectrum class,
  // see BOL_EW_scale_spectrum.hpp.
  {

    return this->particle_spectrum;

  };


  inline std::string get_SLHA_file_name()
  {

    return this->SLHA_file_name;

  };


 

  bool reset()
  // this resets all entries to -10^10 except for the entries in YU, YD, YE, AU, AD & AE, which are reset to 0.0.
  ;

  double get_BLOCK( std::string requested_BLOCK )
  ;


  std::string get_MODSEL_as_string()
  ;


  std::string get_ALPHA_as_string()
  ;


  void set_BLOCK( std::string requested_BLOCK, double set_value )
  ;


  double get_BLOCK( std::string requested_BLOCK, int requested_element )
  ;

  
  double get_MINPAR( int requested_element )
  ;

  std::string get_MINPAR_as_string()
  ;


  double get_EXTPAR( int requested_element )  // EXTPAR has a zero element, so the enumeration is slightly different to MSOFT.
  ;

  std::string get_EXTPAR_as_string()
  ;


  double get_SMINPUTS( int requested_element )
  ;


  std::string get_SMINPUTS_as_string()
  ;


  double get_GAUGE( int requested_element )
  ;


  std::string get_GAUGE_as_string()
  ;


  double get_MSOFT( int requested_element )
  ;


  std::string get_MSOFT_as_string()
  ;


  std::string get_EXTPAR_from_MSOFT_as_string()  // this writes the MSOFT BLOCK as the EXTPAR BLOCK, using the Q which was read in.
  ;


  std::string get_EXTPAR_from_MSOFT_as_string( double given_scale )
  // this writes the MSOFT BLOCK as the EXTPAR BLOCK, with the given scale.
  ;

  double get_MASS( int requested_element )
  ;


  std::string get_MASS_as_string()
  ;


  double get_HMIX( int requested_element )
  ;


  std::string get_HMIX_as_string()
  ;


  double get_SPHENOLOWENERGY( int requested_element )
  ;


  std::string get_SPHENOLOWENERGY_as_string()
  ;


  void set_BLOCK( std::string requested_BLOCK, int requested_element, double set_value )
  ;


  void set_MINPAR( int requested_element, double set_value )
  ;


  void set_EXTPAR( int requested_element, double set_value )
  ;


  void set_SMINPUTS( int requested_element, double set_value )
  ;


  void set_GAUGE( int requested_element, double set_value )
  ;


  void set_MSOFT( int requested_element, double set_value )
  ;


  void set_HMIX( int requested_element, double set_value )
  ;


  void set_SPHENOLOWENERGY( int requested_element, double set_value )
  ;


  double get_BLOCK( std::string requested_BLOCK, int requested_element_one, int requested_element_two )
  ;


  double get_YU( int requested_element_one, int requested_element_two )
  ;


  std::string get_YU_as_string()
  ;


  double get_YD( int requested_element_one, int requested_element_two )
  ;


  std::string get_YD_as_string()
  ;


  double get_YE( int requested_element_one, int requested_element_two )
  ;


  std::string get_YE_as_string()
  ;


  double get_AU( int requested_element_one, int requested_element_two )
  ;


  std::string get_AU_as_string()
  ;


  double get_AD( int requested_element_one, int requested_element_two )
  ;


  std::string get_AD_as_string()
  ;


  double get_AE( int requested_element_one, int requested_element_two )
  ;


  std::string get_AE_as_string()
  ;


  double get_STOPMIX( int requested_element_one, int requested_element_two )
  ;


  std::string get_STOPMIX_as_string()
  ;


  double get_SBOTMIX( int requested_element_one, int requested_element_two )
  ;


  std::string get_SBOTMIX_as_string()
  ;


  double get_STAUMIX( int requested_element_one, int requested_element_two )
  ;


  std::string get_STAUMIX_as_string()
  ;


  double get_NMIX( int requested_element_one, int requested_element_two )
  ;


  std::string get_NMIX_as_string()
  ;

  double get_UMIX( int requested_element_one, int requested_element_two )
  ;


  std::string get_UMIX_as_string()
  ;


  double get_VMIX( int requested_element_one, int requested_element_two )
  ;


  std::string get_VMIX_as_string()
  ;


  void set_BLOCK( std::string requested_BLOCK, int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_YU( int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_YD( int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_YE( int requested_element_one, int requested_element_two, double set_value )
  ;

  void set_AU( int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_AD( int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_AE( int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_STOPMIX( int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_SBOTMIX( int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_STAUMIX( int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_NMIX( int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_UMIX( int requested_element_one, int requested_element_two, double set_value )
  ;


  void set_VMIX( int requested_element_one, int requested_element_two, double set_value )
  ;


  std::string get_BLOCK_as_string( std::string requested_BLOCK )
  ;


  std::string get_DECAY_as_string()
  ;


  bool read_file()  // this reads in the SLHA file and returns true if it was successful.
  ;


   bool read_file( std::string new_SLHA_file_name )  // this reads in the specified SLHA file and returns true if it was successful.
   ;


 //  bool write_file( std::string output_SLHA_file_name )
//   // this writes out all the BLOCKs to a file with the given name (DECAY counts as a BLOCK name in this case).
//   ;


  void write_file( std::string output_SLHA_file_name, std::list< std::string >* list_of_BLOCKS )
  // this writes out the BLOCKs from the supplied list to a file with the given name (DECAY counts as a BLOCK name in this case).
  ;



  // STUFF FOR TESTING PURPOSES!


  int write_particle_spectrum( double minimum_branching_ratio_to_keep, std::string output_file_name )
  // this writes all the stored spectrum data to a file with the provided name.  it returns the number of particle property sets written.
  ;
  // END OF TESTING METHOD!


  ~CppSLHA();  // destructor
  


};

#endif
